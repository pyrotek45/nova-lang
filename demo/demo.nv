module main

// Type declaration
struct Person {
    name: String,
    age: Int,
}

// Hello world
println("hello world!")


// Creating instance of type
let person : Person = Person {name: "bob", age: 42}

// Optional type annotation
let person2 = Person("joe", 50)

// Function for type
fn extends display(self: Person) {
    println(self.name)
    println(self.age)
}

// import function
person.display()
Person::display(person2)

// For loop
for let i = 0; i < 10; i += 1 {
    println(i)
}

import super.std.list

// Array
let arr = [1,2,3]
println(arr)

let arr2 = []: Int.fill(10,5)
println(arr2)

arr[1] = 4
println(arr)

// Changing struct value
person.name = "bingo"
person.display()

struct Zed {
    test: fn()
}

// Creating an instance from a type
let zed = Zed {
    test: || {
        print("wow\n")
    }
}

// Now we can access its namespace and call functions directly
zed::test()

// import iterators
import super.std.iter

let myIter = Iter::fromVec([1,2,3,4,5])
    .map(fn(x:Int)->Int{return x * x})
    .collect()

println(myIter)

// Function pointers
struct SomeFunction {
    function: fn(Int,Int) -> Int
}

let myMul = SomeFunction(fn(x:Int,y:Int)->Int {
    return x * y
})

let myOtherFunc = myMul.function
let simpleSquare = fn(x: Int) -> Int {return x * x};

// Calling function pointer from a struct
println((myMul.function)(4,99))
println(myMul::function(4,99))

// Support for most escape chars
print("hello again!\n")

println(myOtherFunc(4,7))

let myIterTwo = Iter::fromVec([1,2,3,4,5])
    .map(simpleSquare)
    .map(simpleSquare)
    .collect()

println(myIterTwo)

// function overloading
fn add(x:Int,y:Int) -> Int {
    println("im adding ints")
    return x + y
}

fn add(x:Float,y:Float) -> Float {
    println("im adding floats")
    return x + y
}

println(add(1,3))
println(add(1.0,3.0))

// Passing an overloaded function
let myIntAdder = add@(Int,Int)
println(myIntAdder(1,4))

// Generic functions
fn generic(x: $A) {
    println(x)
}

generic("hello!")
generic(10)
generic(5.5)

// More advance structs
struct Counter {
    value: Int,
    count: fn(Counter) -> Int,
    reset: fn(Counter)
}

// Creating a init funciton for Counter
fn CounterInit() -> Counter {
    return Counter {
        value: 0,
        count: fn(self: Counter) -> Int {
            let result = self.value
            self.value += 1
            return result
        },
        reset: fn(self: Counter) {
            self.value = 0
        }
    }
}

// Creating a function for counter outside of the struct
fn extends count(self: Counter) -> Int {
    println("im in a normal function")
    let result = self.value
    self.value += 1
    return result
}

let mycounter = CounterInit()

// The -> takes the function from the struct, and applys it to itself
println(mycounter->count())

// the normal function 'count' will be called here, not from the struct itself
println(mycounter.count())

// Option type lets you represent none
let x: Option(Int) = Some(20)

// import the isSome() function here
if x.isSome() {
    println(x.unwrap())
}

x = None(Int)
if x.isSome() {
    println("i never print")
    println(x.unwrap())
}

fn extends do(x: Option($A), f: fn($A)) {
    if x.isSome() {
        f(x.unwrap())
    }
}

x.do(fn(x:Int) {println(x)})

// String manipulation
let str = "hello world!"
    .chars()
    .filter(fn(x:Char) -> Bool {return (x != 'l') && (x != 'o') })
    .string()

println(str)

// Currying
fn add(x:Int) -> fn(Int) -> fn(Int) -> fn(Int) -> Int {   
    return fn(y:Int) -> fn(Int) -> fn(Int) -> Int {  
        return fn(z:Int) -> fn(Int) -> Int {            
            return fn(t:Int) -> Int {            
                return x + y + z + t
            }            
        }  
    }
}

let inc = add(1)(2)(3)(4)
println(inc)


fn curry(f: fn($A,$A) -> $A) -> fn($A) -> fn($A) -> $A {
    return fn(x: $A) -> fn($A) -> $A {
        return fn(y: $A) -> $A {
            return f(x,y)
        }
    }
}

fn mul(x:Int,y:Int) -> Int {
    return x * y
}

let curriedmul = curry(mul@(Int,Int))

println(curriedmul(5)(5))

// using IO struct
import super.std.io

// let input = io::prompt("wow")
// println(input)
